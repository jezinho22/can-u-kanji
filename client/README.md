Problem domain
English is hard to spell, and it only uses 26 letters. Japanese uses not just sound representation in a different script entirely from English, but also uses kanji. 
Kanji are the logographic Chinese characters taken from the Chinese script, and used in the writing of Japanese. They were made a major part of the Japanese writing system during the time of Old Japanese and are still used, along with the subsequently-derived syllabic scripts of hiragana and katakana.
We want to provide a platform for selecting kanji to learn.

User stories
We want to provide features for people who:
want to track the kanji they have practised
want to select kanji appropriate to their level of learning
want to learn how to draw kanji
want to relate kanji to English meanings
to Japanese usage

Planning
We started from a wireframe and a dicussion of possible user needs

Communication
We used a trello board and discord and github to keep up to date with progress and next tasks. We used branches and pull requests to allow each other to review changes before merging them with the main project. This meant that we could resolve any differences of opinion. We did a lot of paired programming, taking turns driving and navigating, so that we could learn from each other. Later in the week we worked separately but used the above means to communicate.

MVP
Our project is slightly beyond the MVP we set out to achieve. We aimed for 4 database functions and interrogating an API; pages for selecting and reviewing kanji and finding out about the site. We were able to add

The name of the project  
Can U Kanji

Names of the team members
A description of the project
The overall problem domain and how the project solves those problems
Semantic versioning, beginning with version 1.0.0 and incremented as changes are made
A list of any libraries, frameworks, or packages that your application requires in order to properly function
Instructions that the user may need to follow in order to get your application up and running on their own computer
Clearly defined API endpoints with sample responses
Clearly defined database schemas
